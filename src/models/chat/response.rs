use serde::{Deserialize, Serialize};

use super::ChatMessage;

#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatResponse {
    /// Unique identifier for the chat completion
    pub id: Option<String>,

    /// List of chat completion choices
    pub choices: Option<Vec<ChatChoice>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatChoice {
    /// The message generated by the model
    pub message: Option<ChatMessage>,
}

#[cfg(test)]
mod test {
    use super::super::{Content, MessageRole};
    use super::*;

    #[tokio::test]
    async fn test_chat_response_deserialization() {
        let response_json = r#"{
                "id": "chatcmpl-abc123",
                "choices": [
                    {
                        "message": {
                            "role": "assistant",
                            "content": "Hello! I'm doing well, thank you for asking. How can I assist you today?"
                        }
                    }
                ]
            }"#;

        let response: ChatResponse = serde_json::from_str(response_json).unwrap();
        assert_eq!(response.id, Some("chatcmpl-abc123".to_string()));
        assert!(response.choices.is_some());

        let choices = response.choices.unwrap();
        assert_eq!(choices.len(), 1);

        let message = choices[0].message.as_ref().unwrap();
        assert_eq!(message.role, MessageRole::Assistant);
        assert_eq!(
            message.content,
            Content::Simple(
                "Hello! I'm doing well, thank you for asking. How can I assist you today?"
                    .to_string()
            )
        );
    }
}
